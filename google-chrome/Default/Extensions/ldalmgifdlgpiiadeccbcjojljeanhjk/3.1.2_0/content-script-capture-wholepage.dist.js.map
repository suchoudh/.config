{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../node_modules/readability/Readability.js","webpack:///./content-script/capture-wholepage.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Readability","doc","options","documentElement","arguments","Error","logEl","this","_doc","_docJSDOMParser","firstChild","__JSDOMParser__","_articleTitle","_articleByline","_articleDir","_articleSiteName","_attempts","_debug","debug","_maxElemsToParse","maxElemsToParse","DEFAULT_MAX_ELEMS_TO_PARSE","_nbTopCandidates","nbTopCandidates","DEFAULT_N_TOP_CANDIDATES","_charThreshold","charThreshold","DEFAULT_CHAR_THRESHOLD","_classesToPreserve","CLASSES_TO_PRESERVE","concat","classesToPreserve","_keepClasses","keepClasses","_flags","FLAG_STRIP_UNLIKELYS","FLAG_WEIGHT_CLASSES","FLAG_CLEAN_CONDITIONALLY","e","rv","nodeName","nodeType","TEXT_NODE","textContent","classDesc","className","replace","elDesc","id","log","dump","msg","Array","map","x","join","console","args","apply","ELEMENT_NODE","DEFAULT_TAGS_TO_SCORE","toUpperCase","split","REGEXPS","unlikelyCandidates","okMaybeItsACandidate","positive","negative","extraneous","byline","replaceFonts","normalize","videos","shareElements","nextLink","prevLink","whitespace","hasContent","srcsetUrl","b64DataUrl","DIV_TO_P_ELEMS","ALTER_TO_DIV_EXCEPTIONS","PRESENTATIONAL_ATTRIBUTES","DEPRECATED_SIZE_ATTRIBUTE_ELEMS","PHRASING_ELEMS","HTML_ESCAPE_MAP","_postProcessContent","articleContent","_fixRelativeUris","_cleanClasses","_removeNodes","nodeList","filterFn","_isLiveNodeList","length","node","parentNode","removeChild","_replaceNodeTags","newTagName","_setNodeTag","_forEachNode","fn","forEach","_someNode","some","_everyNode","every","_concatNodeLists","slice","nodeLists","list","_getAllNodesWithTag","tagNames","querySelectorAll","tag","collection","getElementsByTagName","isArray","from","getAttribute","filter","cls","indexOf","setAttribute","removeAttribute","firstElementChild","nextElementSibling","baseURI","documentURI","toAbsoluteURI","uri","charAt","URL","href","ex","links","link","childNodes","text","createTextNode","replaceChild","container","createElement","appendChild","medias","media","src","poster","srcset","newSrcset","_","p1","p2","p3","_getArticleTitle","curTitle","origTitle","title","trim","_getInnerText","titleHadHierarchicalSeparators","wordCount","str","test","headings","trimmedTitle","heading","substring","lastIndexOf","substr","hOnes","curTitleWordCount","_prepDocument","body","_replaceBrs","_nextElement","next","nextSibling","elem","br","replaced","tagName","brSibling","nextElem","_isPhrasingContent","sibling","lastChild","_isWhitespace","localName","toLowerCase","replacement","ownerDocument","readability","attributes","_prepArticle","_cleanStyles","_markDataTables","_fixLazyImages","_cleanConditionally","_clean","shareElementThreshold","children","topCandidate","_cleanMatchedNodes","matchString","h2","lengthSimilarRate","Math","abs","includes","_cleanHeaders","paragraph","table","tbody","_hasSingleTagInsideElement","row","cell","_initializeNode","contentScore","_getClassWeight","_removeAndGetNext","nextNode","_getNextNode","ignoreSelfAndKids","_checkByline","undefined","rel","itemprop","_isValidByline","_getNodeAncestors","maxDepth","ancestors","push","_grabArticle","page","isPaging","pageCacheHtml","innerHTML","stripUnlikelyCandidates","_flagIsActive","elementsToScore","_isProbablyVisible","_hasAncestorTag","_isElementWithoutContent","childNode","_getLinkDensity","newNode","_hasChildBlockElement","candidates","elementToScore","innerText","min","floor","ancestor","level","scoreDivider","topCandidates","cl","candidate","candidateScore","aTopCandidate","splice","pop","parentOfTopCandidate","neededToCreateTopCandidate","kids","alternativeCandidateAncestors","listsContainingThisAncestor","ancestorIndex","Number","lastScore","scoreThreshold","parentScore","siblingScoreThreshold","max","siblings","sl","append","contentBonus","linkDensity","nodeContent","nodeLength","search","div","parseSuccessful","textLength","_removeFlag","sort","a","b","articleDir","String","_unescapeHtmlEntities","htmlEscapeMap","hex","numStr","num","parseInt","fromCharCode","_getArticleMetadata","metadata","values","metaElements","propertyPattern","namePattern","element","elementName","elementProperty","content","matches","match","excerpt","siteName","_isSingleImage","_unwrapNoscriptImages","imgs","img","attr","noscripts","noscript","tmp","prevElement","previousElementSibling","prevImg","newImg","attrName","hasAttribute","_removeScripts","scriptNode","nodeValue","normalizeSpaces","_getCharCount","cur","linkLength","linkNode","weight","isEmbed","depth","_getRowAndColumnCount","rows","columns","trs","rowspan","columnsInThisRow","cells","j","colspan","root","tables","_readabilityDataTable","caption","sizeInfo","exec","srcCouldBeRemoved","b64starts","copyTo","isList","isDataTable","li","input","embedCount","embeds","contentLength","endOfSearchMarkerNode","header","flag","style","display","parse","numTags","paragraphs","dir","isFirefox","navigator","userAgent","contentMsg","action","cleanedHTML","loc","document","location","spec","host","prePath","protocol","scheme","pathBase","pathname","documentClone","cloneNode","article","error","warn","getCleanedHtml","originalHTML","head","getOriginalHtml","browser","runtime","sendMessage","chrome"],"mappings":"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","file":"content-script-capture-wholepage.dist.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/*eslint-env es6:false*/\n/*\n * Copyright (c) 2010 Arc90 Inc\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n * This code is heavily based on Arc90's readability.js (1.7.1) script\n * available at: http://code.google.com/p/arc90labs-readability\n */\n\n/**\n * Public constructor.\n * @param {HTMLDocument} doc     The document to parse.\n * @param {Object}       options The options object.\n */\nfunction Readability(doc, options) {\n  // In some older versions, people passed a URI as the first argument. Cope:\n  if (options && options.documentElement) {\n    doc = options;\n    options = arguments[2];\n  } else if (!doc || !doc.documentElement) {\n    throw new Error(\"First argument to Readability constructor should be a document object.\");\n  }\n  options = options || {};\n\n  this._doc = doc;\n  this._docJSDOMParser = this._doc.firstChild.__JSDOMParser__;\n  this._articleTitle = null;\n  this._articleByline = null;\n  this._articleDir = null;\n  this._articleSiteName = null;\n  this._attempts = [];\n\n  // Configurable options\n  this._debug = !!options.debug;\n  this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;\n  this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;\n  this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;\n  this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);\n  this._keepClasses = !!options.keepClasses;\n\n  // Start with all flags set\n  this._flags = this.FLAG_STRIP_UNLIKELYS |\n                this.FLAG_WEIGHT_CLASSES |\n                this.FLAG_CLEAN_CONDITIONALLY;\n\n  var logEl;\n\n  // Control whether log messages are sent to the console\n  if (this._debug) {\n    logEl = function(e) {\n      var rv = e.nodeName + \" \";\n      if (e.nodeType == e.TEXT_NODE) {\n        return rv + '(\"' + e.textContent + '\")';\n      }\n      var classDesc = e.className && (\".\" + e.className.replace(/ /g, \".\"));\n      var elDesc = \"\";\n      if (e.id)\n        elDesc = \"(#\" + e.id + classDesc + \")\";\n      else if (classDesc)\n        elDesc = \"(\" + classDesc + \")\";\n      return rv + elDesc;\n    };\n    this.log = function () {\n      if (typeof dump !== \"undefined\") {\n        var msg = Array.prototype.map.call(arguments, function(x) {\n          return (x && x.nodeName) ? logEl(x) : x;\n        }).join(\" \");\n        dump(\"Reader: (Readability) \" + msg + \"\\n\");\n      } else if (typeof console !== \"undefined\") {\n        var args = [\"Reader: (Readability) \"].concat(arguments);\n        console.log.apply(console, args);\n      }\n    };\n  } else {\n    this.log = function () {};\n  }\n}\n\nReadability.prototype = {\n  FLAG_STRIP_UNLIKELYS: 0x1,\n  FLAG_WEIGHT_CLASSES: 0x2,\n  FLAG_CLEAN_CONDITIONALLY: 0x4,\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  ELEMENT_NODE: 1,\n  TEXT_NODE: 3,\n\n  // Max number of nodes supported by this parser. Default: 0 (no limit)\n  DEFAULT_MAX_ELEMS_TO_PARSE: 0,\n\n  // The number of top candidates to consider when analysing how\n  // tight the competition is among candidates.\n  DEFAULT_N_TOP_CANDIDATES: 5,\n\n  // Element tags to score by default.\n  DEFAULT_TAGS_TO_SCORE: \"section,h2,h3,h4,h5,h6,p,td,pre\".toUpperCase().split(\",\"),\n\n  // The default number of chars an article must have in order to return a result\n  DEFAULT_CHAR_THRESHOLD: 500,\n\n  // All of the regular expressions in use within readability.\n  // Defined up here so we don't instantiate them repeatedly in loops.\n  REGEXPS: {\n    // NOTE: These two regular expressions are duplicated in\n    // Readability-readerable.js. Please keep both copies in sync.\n    unlikelyCandidates: /-ad-|ai2html|banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|footer|gdpr|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote/i,\n    okMaybeItsACandidate: /and|article|body|column|content|main|shadow/i,\n\n    positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story/i,\n    negative: /hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|gdpr|masthead|media|meta|outbrain|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget/i,\n    extraneous: /print|archive|comment|discuss|e[\\-]?mail|share|reply|all|login|sign|single|utility/i,\n    byline: /byline|author|dateline|writtenby|p-author/i,\n    replaceFonts: /<(\\/?)font[^>]*>/gi,\n    normalize: /\\s{2,}/g,\n    videos: /\\/\\/(www\\.)?((dailymotion|youtube|youtube-nocookie|player\\.vimeo|v\\.qq)\\.com|(archive|upload\\.wikimedia)\\.org|player\\.twitch\\.tv)/i,\n    shareElements: /(\\b|_)(share|sharedaddy)(\\b|_)/i,\n    nextLink: /(next|weiter|continue|>([^\\|]|$)|»([^\\|]|$))/i,\n    prevLink: /(prev|earl|old|new|<|«)/i,\n    whitespace: /^\\s*$/,\n    hasContent: /\\S$/,\n    srcsetUrl: /(\\S+)(\\s+[\\d.]+[xw])?(\\s*(?:,|$))/g,\n    b64DataUrl: /^data:\\s*([^\\s;,]+)\\s*;\\s*base64\\s*,/i\n  },\n\n  DIV_TO_P_ELEMS: [ \"A\", \"BLOCKQUOTE\", \"DL\", \"DIV\", \"IMG\", \"OL\", \"P\", \"PRE\", \"TABLE\", \"UL\", \"SELECT\" ],\n\n  ALTER_TO_DIV_EXCEPTIONS: [\"DIV\", \"ARTICLE\", \"SECTION\", \"P\"],\n\n  PRESENTATIONAL_ATTRIBUTES: [ \"align\", \"background\", \"bgcolor\", \"border\", \"cellpadding\", \"cellspacing\", \"frame\", \"hspace\", \"rules\", \"style\", \"valign\", \"vspace\" ],\n\n  DEPRECATED_SIZE_ATTRIBUTE_ELEMS: [ \"TABLE\", \"TH\", \"TD\", \"HR\", \"PRE\" ],\n\n  // The commented out elements qualify as phrasing content but tend to be\n  // removed by readability when put into paragraphs, so we ignore them here.\n  PHRASING_ELEMS: [\n    // \"CANVAS\", \"IFRAME\", \"SVG\", \"VIDEO\",\n    \"ABBR\", \"AUDIO\", \"B\", \"BDO\", \"BR\", \"BUTTON\", \"CITE\", \"CODE\", \"DATA\",\n    \"DATALIST\", \"DFN\", \"EM\", \"EMBED\", \"I\", \"IMG\", \"INPUT\", \"KBD\", \"LABEL\",\n    \"MARK\", \"MATH\", \"METER\", \"NOSCRIPT\", \"OBJECT\", \"OUTPUT\", \"PROGRESS\", \"Q\",\n    \"RUBY\", \"SAMP\", \"SCRIPT\", \"SELECT\", \"SMALL\", \"SPAN\", \"STRONG\", \"SUB\",\n    \"SUP\", \"TEXTAREA\", \"TIME\", \"VAR\", \"WBR\"\n  ],\n\n  // These are the classes that readability sets itself.\n  CLASSES_TO_PRESERVE: [ \"page\" ],\n\n  // These are the list of HTML entities that need to be escaped.\n  HTML_ESCAPE_MAP: {\n    \"lt\": \"<\",\n    \"gt\": \">\",\n    \"amp\": \"&\",\n    \"quot\": '\"',\n    \"apos\": \"'\",\n  },\n\n  /**\n   * Run any post-process modifications to article content as necessary.\n   *\n   * @param Element\n   * @return void\n  **/\n  _postProcessContent: function(articleContent) {\n    // Readability cannot open relative uris so we convert them to absolute uris.\n    this._fixRelativeUris(articleContent);\n\n    if (!this._keepClasses) {\n      // Remove classes.\n      this._cleanClasses(articleContent);\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, calls `filterFn` for each node and removes node\n   * if function returned `true`.\n   *\n   * If function is not passed, removes all the nodes in node list.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param Function filterFn the function to use as a filter\n   * @return void\n   */\n  _removeNodes: function(nodeList, filterFn) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _removeNodes\");\n    }\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      var parentNode = node.parentNode;\n      if (parentNode) {\n        if (!filterFn || filterFn.call(this, node, i, nodeList)) {\n          parentNode.removeChild(node);\n        }\n      }\n    }\n  },\n\n  /**\n   * Iterates over a NodeList, and calls _setNodeTag for each node.\n   *\n   * @param NodeList nodeList The nodes to operate on\n   * @param String newTagName the new tag name to use\n   * @return void\n   */\n  _replaceNodeTags: function(nodeList, newTagName) {\n    // Avoid ever operating on live node lists.\n    if (this._docJSDOMParser && nodeList._isLiveNodeList) {\n      throw new Error(\"Do not pass live node lists to _replaceNodeTags\");\n    }\n    for (var i = nodeList.length - 1; i >= 0; i--) {\n      var node = nodeList[i];\n      this._setNodeTag(node, newTagName);\n    }\n  },\n\n  /**\n   * Iterate over a NodeList, which doesn't natively fully implement the Array\n   * interface.\n   *\n   * For convenience, the current object context is applied to the provided\n   * iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return void\n   */\n  _forEachNode: function(nodeList, fn) {\n    Array.prototype.forEach.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if any of the provided iterate\n   * function calls returns true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _someNode: function(nodeList, fn) {\n    return Array.prototype.some.call(nodeList, fn, this);\n  },\n\n  /**\n   * Iterate over a NodeList, return true if all of the provided iterate\n   * function calls return true, false otherwise.\n   *\n   * For convenience, the current object context is applied to the\n   * provided iterate function.\n   *\n   * @param  NodeList nodeList The NodeList.\n   * @param  Function fn       The iterate function.\n   * @return Boolean\n   */\n  _everyNode: function(nodeList, fn) {\n    return Array.prototype.every.call(nodeList, fn, this);\n  },\n\n  /**\n   * Concat all nodelists passed as arguments.\n   *\n   * @return ...NodeList\n   * @return Array\n   */\n  _concatNodeLists: function() {\n    var slice = Array.prototype.slice;\n    var args = slice.call(arguments);\n    var nodeLists = args.map(function(list) {\n      return slice.call(list);\n    });\n    return Array.prototype.concat.apply([], nodeLists);\n  },\n\n  _getAllNodesWithTag: function(node, tagNames) {\n    if (node.querySelectorAll) {\n      return node.querySelectorAll(tagNames.join(\",\"));\n    }\n    return [].concat.apply([], tagNames.map(function(tag) {\n      var collection = node.getElementsByTagName(tag);\n      return Array.isArray(collection) ? collection : Array.from(collection);\n    }));\n  },\n\n  /**\n   * Removes the class=\"\" attribute from every element in the given\n   * subtree, except those that match CLASSES_TO_PRESERVE and\n   * the classesToPreserve array from the options object.\n   *\n   * @param Element\n   * @return void\n   */\n  _cleanClasses: function(node) {\n    var classesToPreserve = this._classesToPreserve;\n    var className = (node.getAttribute(\"class\") || \"\")\n      .split(/\\s+/)\n      .filter(function(cls) {\n        return classesToPreserve.indexOf(cls) != -1;\n      })\n      .join(\" \");\n\n    if (className) {\n      node.setAttribute(\"class\", className);\n    } else {\n      node.removeAttribute(\"class\");\n    }\n\n    for (node = node.firstElementChild; node; node = node.nextElementSibling) {\n      this._cleanClasses(node);\n    }\n  },\n\n  /**\n   * Converts each <a> and <img> uri in the given element to an absolute URI,\n   * ignoring #ref URIs.\n   *\n   * @param Element\n   * @return void\n   */\n  _fixRelativeUris: function(articleContent) {\n    var baseURI = this._doc.baseURI;\n    var documentURI = this._doc.documentURI;\n    function toAbsoluteURI(uri) {\n      // Leave hash links alone if the base URI matches the document URI:\n      if (baseURI == documentURI && uri.charAt(0) == \"#\") {\n        return uri;\n      }\n\n      // Otherwise, resolve against base URI:\n      try {\n        return new URL(uri, baseURI).href;\n      } catch (ex) {\n        // Something went wrong, just return the original:\n      }\n      return uri;\n    }\n\n    var links = this._getAllNodesWithTag(articleContent, [\"a\"]);\n    this._forEachNode(links, function(link) {\n      var href = link.getAttribute(\"href\");\n      if (href) {\n        // Remove links with javascript: URIs, since\n        // they won't work after scripts have been removed from the page.\n        if (href.indexOf(\"javascript:\") === 0) {\n          // if the link only contains simple text content, it can be converted to a text node\n          if (link.childNodes.length === 1 && link.childNodes[0].nodeType === this.TEXT_NODE) {\n            var text = this._doc.createTextNode(link.textContent);\n            link.parentNode.replaceChild(text, link);\n          } else {\n            // if the link has multiple children, they should all be preserved\n            var container = this._doc.createElement(\"span\");\n            while (link.childNodes.length > 0) {\n              container.appendChild(link.childNodes[0]);\n            }\n            link.parentNode.replaceChild(container, link);\n          }\n        } else {\n          link.setAttribute(\"href\", toAbsoluteURI(href));\n        }\n      }\n    });\n\n    var medias = this._getAllNodesWithTag(articleContent, [\n      \"img\", \"picture\", \"figure\", \"video\", \"audio\", \"source\"\n    ]);\n\n    this._forEachNode(medias, function(media) {\n      var src = media.getAttribute(\"src\");\n      var poster = media.getAttribute(\"poster\");\n      var srcset = media.getAttribute(\"srcset\");\n\n      if (src) {\n        media.setAttribute(\"src\", toAbsoluteURI(src));\n      }\n\n      if (poster) {\n        media.setAttribute(\"poster\", toAbsoluteURI(poster));\n      }\n\n      if (srcset) {\n        var newSrcset = srcset.replace(this.REGEXPS.srcsetUrl, function(_, p1, p2, p3) {\n          return toAbsoluteURI(p1) + (p2 || \"\") + p3;\n        });\n\n        media.setAttribute(\"srcset\", newSrcset);\n      }\n    });\n  },\n\n  /**\n   * Get the article title as an H1.\n   *\n   * @return void\n   **/\n  _getArticleTitle: function() {\n    var doc = this._doc;\n    var curTitle = \"\";\n    var origTitle = \"\";\n\n    try {\n      curTitle = origTitle = doc.title.trim();\n\n      // If they had an element with id \"title\" in their HTML\n      if (typeof curTitle !== \"string\")\n        curTitle = origTitle = this._getInnerText(doc.getElementsByTagName(\"title\")[0]);\n    } catch (e) {/* ignore exceptions setting the title. */}\n\n    var titleHadHierarchicalSeparators = false;\n    function wordCount(str) {\n      return str.split(/\\s+/).length;\n    }\n\n    // If there's a separator in the title, first remove the final part\n    if ((/ [\\|\\-\\\\\\/>»] /).test(curTitle)) {\n      titleHadHierarchicalSeparators = / [\\\\\\/>»] /.test(curTitle);\n      curTitle = origTitle.replace(/(.*)[\\|\\-\\\\\\/>»] .*/gi, \"$1\");\n\n      // If the resulting title is too short (3 words or fewer), remove\n      // the first part instead:\n      if (wordCount(curTitle) < 3)\n        curTitle = origTitle.replace(/[^\\|\\-\\\\\\/>»]*[\\|\\-\\\\\\/>»](.*)/gi, \"$1\");\n    } else if (curTitle.indexOf(\": \") !== -1) {\n      // Check if we have an heading containing this exact string, so we\n      // could assume it's the full title.\n      var headings = this._concatNodeLists(\n        doc.getElementsByTagName(\"h1\"),\n        doc.getElementsByTagName(\"h2\")\n      );\n      var trimmedTitle = curTitle.trim();\n      var match = this._someNode(headings, function(heading) {\n        return heading.textContent.trim() === trimmedTitle;\n      });\n\n      // If we don't, let's extract the title out of the original title string.\n      if (!match) {\n        curTitle = origTitle.substring(origTitle.lastIndexOf(\":\") + 1);\n\n        // If the title is now too short, try the first colon instead:\n        if (wordCount(curTitle) < 3) {\n          curTitle = origTitle.substring(origTitle.indexOf(\":\") + 1);\n          // But if we have too many words before the colon there's something weird\n          // with the titles and the H tags so let's just use the original title instead\n        } else if (wordCount(origTitle.substr(0, origTitle.indexOf(\":\"))) > 5) {\n          curTitle = origTitle;\n        }\n      }\n    } else if (curTitle.length > 150 || curTitle.length < 15) {\n      var hOnes = doc.getElementsByTagName(\"h1\");\n\n      if (hOnes.length === 1)\n        curTitle = this._getInnerText(hOnes[0]);\n    }\n\n    curTitle = curTitle.trim().replace(this.REGEXPS.normalize, \" \");\n    // If we now have 4 words or fewer as our title, and either no\n    // 'hierarchical' separators (\\, /, > or ») were found in the original\n    // title or we decreased the number of words by more than 1 word, use\n    // the original title.\n    var curTitleWordCount = wordCount(curTitle);\n    if (curTitleWordCount <= 4 &&\n        (!titleHadHierarchicalSeparators ||\n         curTitleWordCount != wordCount(origTitle.replace(/[\\|\\-\\\\\\/>»]+/g, \"\")) - 1)) {\n      curTitle = origTitle;\n    }\n\n    return curTitle;\n  },\n\n  /**\n   * Prepare the HTML document for readability to scrape it.\n   * This includes things like stripping javascript, CSS, and handling terrible markup.\n   *\n   * @return void\n   **/\n  _prepDocument: function() {\n    var doc = this._doc;\n\n    // Remove all style tags in head\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"style\"]));\n\n    if (doc.body) {\n      this._replaceBrs(doc.body);\n    }\n\n    this._replaceNodeTags(this._getAllNodesWithTag(doc, [\"font\"]), \"SPAN\");\n  },\n\n  /**\n   * Finds the next element, starting from the given node, and ignoring\n   * whitespace in between. If the given node is an element, the same node is\n   * returned.\n   */\n  _nextElement: function (node) {\n    var next = node;\n    while (next\n        && (next.nodeType != this.ELEMENT_NODE)\n        && this.REGEXPS.whitespace.test(next.textContent)) {\n      next = next.nextSibling;\n    }\n    return next;\n  },\n\n  /**\n   * Replaces 2 or more successive <br> elements with a single <p>.\n   * Whitespace between <br> elements are ignored. For example:\n   *   <div>foo<br>bar<br> <br><br>abc</div>\n   * will become:\n   *   <div>foo<br>bar<p>abc</p></div>\n   */\n  _replaceBrs: function (elem) {\n    this._forEachNode(this._getAllNodesWithTag(elem, [\"br\"]), function(br) {\n      var next = br.nextSibling;\n\n      // Whether 2 or more <br> elements have been found and replaced with a\n      // <p> block.\n      var replaced = false;\n\n      // If we find a <br> chain, remove the <br>s until we hit another element\n      // or non-whitespace. This leaves behind the first <br> in the chain\n      // (which will be replaced with a <p> later).\n      while ((next = this._nextElement(next)) && (next.tagName == \"BR\")) {\n        replaced = true;\n        var brSibling = next.nextSibling;\n        next.parentNode.removeChild(next);\n        next = brSibling;\n      }\n\n      // If we removed a <br> chain, replace the remaining <br> with a <p>. Add\n      // all sibling nodes as children of the <p> until we hit another <br>\n      // chain.\n      if (replaced) {\n        var p = this._doc.createElement(\"p\");\n        br.parentNode.replaceChild(p, br);\n\n        next = p.nextSibling;\n        while (next) {\n          // If we've hit another <br><br>, we're done adding children to this <p>.\n          if (next.tagName == \"BR\") {\n            var nextElem = this._nextElement(next.nextSibling);\n            if (nextElem && nextElem.tagName == \"BR\")\n              break;\n          }\n\n          if (!this._isPhrasingContent(next))\n            break;\n\n          // Otherwise, make this node a child of the new <p>.\n          var sibling = next.nextSibling;\n          p.appendChild(next);\n          next = sibling;\n        }\n\n        while (p.lastChild && this._isWhitespace(p.lastChild)) {\n          p.removeChild(p.lastChild);\n        }\n\n        if (p.parentNode.tagName === \"P\")\n          this._setNodeTag(p.parentNode, \"DIV\");\n      }\n    });\n  },\n\n  _setNodeTag: function (node, tag) {\n    this.log(\"_setNodeTag\", node, tag);\n    if (this._docJSDOMParser) {\n      node.localName = tag.toLowerCase();\n      node.tagName = tag.toUpperCase();\n      return node;\n    }\n\n    var replacement = node.ownerDocument.createElement(tag);\n    while (node.firstChild) {\n      replacement.appendChild(node.firstChild);\n    }\n    node.parentNode.replaceChild(replacement, node);\n    if (node.readability)\n      replacement.readability = node.readability;\n\n    for (var i = 0; i < node.attributes.length; i++) {\n      try {\n        replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);\n      } catch (ex) {\n        /* it's possible for setAttribute() to throw if the attribute name\n         * isn't a valid XML Name. Such attributes can however be parsed from\n         * source in HTML docs, see https://github.com/whatwg/html/issues/4275,\n         * so we can hit them here and then throw. We don't care about such\n         * attributes so we ignore them.\n         */\n      }\n    }\n    return replacement;\n  },\n\n  /**\n   * Prepare the article node for display. Clean out any inline styles,\n   * iframes, forms, strip extraneous <p> tags, etc.\n   *\n   * @param Element\n   * @return void\n   **/\n  _prepArticle: function(articleContent) {\n    this._cleanStyles(articleContent);\n\n    // Check for data tables before we continue, to avoid removing items in\n    // those tables, which will often be isolated even though they're\n    // visually linked to other content-ful elements (text, images, etc.).\n    this._markDataTables(articleContent);\n\n    this._fixLazyImages(articleContent);\n\n    // Clean out junk from the article content\n    this._cleanConditionally(articleContent, \"form\");\n    this._cleanConditionally(articleContent, \"fieldset\");\n    this._clean(articleContent, \"object\");\n    this._clean(articleContent, \"embed\");\n    this._clean(articleContent, \"h1\");\n    this._clean(articleContent, \"footer\");\n    this._clean(articleContent, \"link\");\n    this._clean(articleContent, \"aside\");\n\n    // Clean out elements with little content that have \"share\" in their id/class combinations from final top candidates,\n    // which means we don't remove the top candidates even they have \"share\".\n\n    var shareElementThreshold = this.DEFAULT_CHAR_THRESHOLD;\n\n    this._forEachNode(articleContent.children, function (topCandidate) {\n      this._cleanMatchedNodes(topCandidate, function (node, matchString) {\n        return this.REGEXPS.shareElements.test(matchString) && node.textContent.length < shareElementThreshold;\n      });\n    });\n\n    // If there is only one h2 and its text content substantially equals article title,\n    // they are probably using it as a header and not a subheader,\n    // so remove it since we already extract the title separately.\n    var h2 = articleContent.getElementsByTagName(\"h2\");\n    if (h2.length === 1) {\n      var lengthSimilarRate = (h2[0].textContent.length - this._articleTitle.length) / this._articleTitle.length;\n      if (Math.abs(lengthSimilarRate) < 0.5) {\n        var titlesMatch = false;\n        if (lengthSimilarRate > 0) {\n          titlesMatch = h2[0].textContent.includes(this._articleTitle);\n        } else {\n          titlesMatch = this._articleTitle.includes(h2[0].textContent);\n        }\n        if (titlesMatch) {\n          this._clean(articleContent, \"h2\");\n        }\n      }\n    }\n\n    this._clean(articleContent, \"iframe\");\n    this._clean(articleContent, \"input\");\n    this._clean(articleContent, \"textarea\");\n    this._clean(articleContent, \"select\");\n    this._clean(articleContent, \"button\");\n    this._cleanHeaders(articleContent);\n\n    // Do these last as the previous stuff may have removed junk\n    // that will affect these\n    this._cleanConditionally(articleContent, \"table\");\n    this._cleanConditionally(articleContent, \"ul\");\n    this._cleanConditionally(articleContent, \"div\");\n\n    // Remove extra paragraphs\n    this._removeNodes(this._getAllNodesWithTag(articleContent, [\"p\"]), function (paragraph) {\n      var imgCount = paragraph.getElementsByTagName(\"img\").length;\n      var embedCount = paragraph.getElementsByTagName(\"embed\").length;\n      var objectCount = paragraph.getElementsByTagName(\"object\").length;\n      // At this point, nasty iframes have been removed, only remain embedded video ones.\n      var iframeCount = paragraph.getElementsByTagName(\"iframe\").length;\n      var totalCount = imgCount + embedCount + objectCount + iframeCount;\n\n      return totalCount === 0 && !this._getInnerText(paragraph, false);\n    });\n\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"br\"]), function(br) {\n      var next = this._nextElement(br.nextSibling);\n      if (next && next.tagName == \"P\")\n        br.parentNode.removeChild(br);\n    });\n\n    // Remove single-cell tables\n    this._forEachNode(this._getAllNodesWithTag(articleContent, [\"table\"]), function(table) {\n      var tbody = this._hasSingleTagInsideElement(table, \"TBODY\") ? table.firstElementChild : table;\n      if (this._hasSingleTagInsideElement(tbody, \"TR\")) {\n        var row = tbody.firstElementChild;\n        if (this._hasSingleTagInsideElement(row, \"TD\")) {\n          var cell = row.firstElementChild;\n          cell = this._setNodeTag(cell, this._everyNode(cell.childNodes, this._isPhrasingContent) ? \"P\" : \"DIV\");\n          table.parentNode.replaceChild(cell, table);\n        }\n      }\n    });\n  },\n\n  /**\n   * Initialize a node with the readability object. Also checks the\n   * className/id for special names to add to its score.\n   *\n   * @param Element\n   * @return void\n  **/\n  _initializeNode: function(node) {\n    node.readability = {\"contentScore\": 0};\n\n    switch (node.tagName) {\n      case \"DIV\":\n        node.readability.contentScore += 5;\n        break;\n\n      case \"PRE\":\n      case \"TD\":\n      case \"BLOCKQUOTE\":\n        node.readability.contentScore += 3;\n        break;\n\n      case \"ADDRESS\":\n      case \"OL\":\n      case \"UL\":\n      case \"DL\":\n      case \"DD\":\n      case \"DT\":\n      case \"LI\":\n      case \"FORM\":\n        node.readability.contentScore -= 3;\n        break;\n\n      case \"H1\":\n      case \"H2\":\n      case \"H3\":\n      case \"H4\":\n      case \"H5\":\n      case \"H6\":\n      case \"TH\":\n        node.readability.contentScore -= 5;\n        break;\n    }\n\n    node.readability.contentScore += this._getClassWeight(node);\n  },\n\n  _removeAndGetNext: function(node) {\n    var nextNode = this._getNextNode(node, true);\n    node.parentNode.removeChild(node);\n    return nextNode;\n  },\n\n  /**\n   * Traverse the DOM from node to node, starting at the node passed in.\n   * Pass true for the second parameter to indicate this node itself\n   * (and its kids) are going away, and we want the next node over.\n   *\n   * Calling this in a loop will traverse the DOM depth-first.\n   */\n  _getNextNode: function(node, ignoreSelfAndKids) {\n    // First check for kids if those aren't being ignored\n    if (!ignoreSelfAndKids && node.firstElementChild) {\n      return node.firstElementChild;\n    }\n    // Then for siblings...\n    if (node.nextElementSibling) {\n      return node.nextElementSibling;\n    }\n    // And finally, move up the parent chain *and* find a sibling\n    // (because this is depth-first traversal, we will have already\n    // seen the parent nodes themselves).\n    do {\n      node = node.parentNode;\n    } while (node && !node.nextElementSibling);\n    return node && node.nextElementSibling;\n  },\n\n  _checkByline: function(node, matchString) {\n    if (this._articleByline) {\n      return false;\n    }\n\n    if (node.getAttribute !== undefined) {\n      var rel = node.getAttribute(\"rel\");\n      var itemprop = node.getAttribute(\"itemprop\");\n    }\n\n    if ((rel === \"author\" || (itemprop && itemprop.indexOf(\"author\") !== -1) || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {\n      this._articleByline = node.textContent.trim();\n      return true;\n    }\n\n    return false;\n  },\n\n  _getNodeAncestors: function(node, maxDepth) {\n    maxDepth = maxDepth || 0;\n    var i = 0, ancestors = [];\n    while (node.parentNode) {\n      ancestors.push(node.parentNode);\n      if (maxDepth && ++i === maxDepth)\n        break;\n      node = node.parentNode;\n    }\n    return ancestors;\n  },\n\n  /***\n   * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is\n   *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.\n   *\n   * @param page a document to run upon. Needs to be a full document, complete with body.\n   * @return Element\n  **/\n  _grabArticle: function (page) {\n    this.log(\"**** grabArticle ****\");\n    var doc = this._doc;\n    var isPaging = (page !== null ? true: false);\n    page = page ? page : this._doc.body;\n\n    // We can't grab an article if we don't have a page!\n    if (!page) {\n      this.log(\"No body found in document. Abort.\");\n      return null;\n    }\n\n    var pageCacheHtml = page.innerHTML;\n\n    while (true) {\n      var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);\n\n      // First, node prepping. Trash nodes that look cruddy (like ones with the\n      // class name \"comment\", etc), and turn divs into P tags where they have been\n      // used inappropriately (as in, where they contain no other block level elements.)\n      var elementsToScore = [];\n      var node = this._doc.documentElement;\n\n      while (node) {\n        var matchString = node.className + \" \" + node.id;\n\n        if (!this._isProbablyVisible(node)) {\n          this.log(\"Removing hidden node - \" + matchString);\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Check to see if this node is a byline, and remove it if it is.\n        if (this._checkByline(node, matchString)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        // Remove unlikely candidates\n        if (stripUnlikelyCandidates) {\n          if (this.REGEXPS.unlikelyCandidates.test(matchString) &&\n              !this.REGEXPS.okMaybeItsACandidate.test(matchString) &&\n              !this._hasAncestorTag(node, \"table\") &&\n              node.tagName !== \"BODY\" &&\n              node.tagName !== \"A\") {\n            this.log(\"Removing unlikely candidate - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n\n          if (node.getAttribute(\"role\") == \"complementary\") {\n            this.log(\"Removing complementary content - \" + matchString);\n            node = this._removeAndGetNext(node);\n            continue;\n          }\n        }\n\n        // Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).\n        if ((node.tagName === \"DIV\" || node.tagName === \"SECTION\" || node.tagName === \"HEADER\" ||\n             node.tagName === \"H1\" || node.tagName === \"H2\" || node.tagName === \"H3\" ||\n             node.tagName === \"H4\" || node.tagName === \"H5\" || node.tagName === \"H6\") &&\n            this._isElementWithoutContent(node)) {\n          node = this._removeAndGetNext(node);\n          continue;\n        }\n\n        if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {\n          elementsToScore.push(node);\n        }\n\n        // Turn all divs that don't have children block level elements into p's\n        if (node.tagName === \"DIV\") {\n          // Put phrasing content into paragraphs.\n          var p = null;\n          var childNode = node.firstChild;\n          while (childNode) {\n            var nextSibling = childNode.nextSibling;\n            if (this._isPhrasingContent(childNode)) {\n              if (p !== null) {\n                p.appendChild(childNode);\n              } else if (!this._isWhitespace(childNode)) {\n                p = doc.createElement(\"p\");\n                node.replaceChild(p, childNode);\n                p.appendChild(childNode);\n              }\n            } else if (p !== null) {\n              while (p.lastChild && this._isWhitespace(p.lastChild)) {\n                p.removeChild(p.lastChild);\n              }\n              p = null;\n            }\n            childNode = nextSibling;\n          }\n\n          // Sites like http://mobile.slate.com encloses each paragraph with a DIV\n          // element. DIVs with only a P element inside and no text content can be\n          // safely converted into plain P elements to avoid confusing the scoring\n          // algorithm with DIVs with are, in practice, paragraphs.\n          if (this._hasSingleTagInsideElement(node, \"P\") && this._getLinkDensity(node) < 0.25) {\n            var newNode = node.children[0];\n            node.parentNode.replaceChild(newNode, node);\n            node = newNode;\n            elementsToScore.push(node);\n          } else if (!this._hasChildBlockElement(node)) {\n            node = this._setNodeTag(node, \"P\");\n            elementsToScore.push(node);\n          }\n        }\n        node = this._getNextNode(node);\n      }\n\n      /**\n       * Loop through all paragraphs, and assign a score to them based on how content-y they look.\n       * Then add their score to their parent node.\n       *\n       * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.\n      **/\n      var candidates = [];\n      this._forEachNode(elementsToScore, function(elementToScore) {\n        if (!elementToScore.parentNode || typeof(elementToScore.parentNode.tagName) === \"undefined\")\n          return;\n\n        // If this paragraph is less than 25 characters, don't even count it.\n        var innerText = this._getInnerText(elementToScore);\n        if (innerText.length < 25)\n          return;\n\n        // Exclude nodes with no ancestor.\n        var ancestors = this._getNodeAncestors(elementToScore, 3);\n        if (ancestors.length === 0)\n          return;\n\n        var contentScore = 0;\n\n        // Add a point for the paragraph itself as a base.\n        contentScore += 1;\n\n        // Add points for any commas within this paragraph.\n        contentScore += innerText.split(\",\").length;\n\n        // For every 100 characters in this paragraph, add another point. Up to 3 points.\n        contentScore += Math.min(Math.floor(innerText.length / 100), 3);\n\n        // Initialize and score ancestors.\n        this._forEachNode(ancestors, function(ancestor, level) {\n          if (!ancestor.tagName || !ancestor.parentNode || typeof(ancestor.parentNode.tagName) === \"undefined\")\n            return;\n\n          if (typeof(ancestor.readability) === \"undefined\") {\n            this._initializeNode(ancestor);\n            candidates.push(ancestor);\n          }\n\n          // Node score divider:\n          // - parent:             1 (no division)\n          // - grandparent:        2\n          // - great grandparent+: ancestor level * 3\n          if (level === 0)\n            var scoreDivider = 1;\n          else if (level === 1)\n            scoreDivider = 2;\n          else\n            scoreDivider = level * 3;\n          ancestor.readability.contentScore += contentScore / scoreDivider;\n        });\n      });\n\n      // After we've calculated scores, loop through all of the possible\n      // candidate nodes we found and find the one with the highest score.\n      var topCandidates = [];\n      for (var c = 0, cl = candidates.length; c < cl; c += 1) {\n        var candidate = candidates[c];\n\n        // Scale the final candidates score based on link density. Good content\n        // should have a relatively small link density (5% or less) and be mostly\n        // unaffected by this operation.\n        var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));\n        candidate.readability.contentScore = candidateScore;\n\n        this.log(\"Candidate:\", candidate, \"with score \" + candidateScore);\n\n        for (var t = 0; t < this._nbTopCandidates; t++) {\n          var aTopCandidate = topCandidates[t];\n\n          if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {\n            topCandidates.splice(t, 0, candidate);\n            if (topCandidates.length > this._nbTopCandidates)\n              topCandidates.pop();\n            break;\n          }\n        }\n      }\n\n      var topCandidate = topCandidates[0] || null;\n      var neededToCreateTopCandidate = false;\n      var parentOfTopCandidate;\n\n      // If we still have no top candidate, just use the body as a last resort.\n      // We also have to copy the body node so it is something we can modify.\n      if (topCandidate === null || topCandidate.tagName === \"BODY\") {\n        // Move all of the page's children into topCandidate\n        topCandidate = doc.createElement(\"DIV\");\n        neededToCreateTopCandidate = true;\n        // Move everything (not just elements, also text nodes etc.) into the container\n        // so we even include text directly in the body:\n        var kids = page.childNodes;\n        while (kids.length) {\n          this.log(\"Moving child out:\", kids[0]);\n          topCandidate.appendChild(kids[0]);\n        }\n\n        page.appendChild(topCandidate);\n\n        this._initializeNode(topCandidate);\n      } else if (topCandidate) {\n        // Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array\n        // and whose scores are quite closed with current `topCandidate` node.\n        var alternativeCandidateAncestors = [];\n        for (var i = 1; i < topCandidates.length; i++) {\n          if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {\n            alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));\n          }\n        }\n        var MINIMUM_TOPCANDIDATES = 3;\n        if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {\n          parentOfTopCandidate = topCandidate.parentNode;\n          while (parentOfTopCandidate.tagName !== \"BODY\") {\n            var listsContainingThisAncestor = 0;\n            for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {\n              listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));\n            }\n            if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {\n              topCandidate = parentOfTopCandidate;\n              break;\n            }\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n          }\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n\n        // Because of our bonus system, parents of candidates might have scores\n        // themselves. They get half of the node. There won't be nodes with higher\n        // scores than our topCandidate, but if we see the score going *up* in the first\n        // few steps up the tree, that's a decent sign that there might be more content\n        // lurking in other places that we want to unify in. The sibling stuff\n        // below does some of that - but only if we've looked high enough up the DOM\n        // tree.\n        parentOfTopCandidate = topCandidate.parentNode;\n        var lastScore = topCandidate.readability.contentScore;\n        // The scores shouldn't get too low.\n        var scoreThreshold = lastScore / 3;\n        while (parentOfTopCandidate.tagName !== \"BODY\") {\n          if (!parentOfTopCandidate.readability) {\n            parentOfTopCandidate = parentOfTopCandidate.parentNode;\n            continue;\n          }\n          var parentScore = parentOfTopCandidate.readability.contentScore;\n          if (parentScore < scoreThreshold)\n            break;\n          if (parentScore > lastScore) {\n            // Alright! We found a better parent to use.\n            topCandidate = parentOfTopCandidate;\n            break;\n          }\n          lastScore = parentOfTopCandidate.readability.contentScore;\n          parentOfTopCandidate = parentOfTopCandidate.parentNode;\n        }\n\n        // If the top candidate is the only child, use parent instead. This will help sibling\n        // joining logic when adjacent content is actually located in parent's sibling node.\n        parentOfTopCandidate = topCandidate.parentNode;\n        while (parentOfTopCandidate.tagName != \"BODY\" && parentOfTopCandidate.children.length == 1) {\n          topCandidate = parentOfTopCandidate;\n          parentOfTopCandidate = topCandidate.parentNode;\n        }\n        if (!topCandidate.readability) {\n          this._initializeNode(topCandidate);\n        }\n      }\n\n      // Now that we have the top candidate, look through its siblings for content\n      // that might also be related. Things like preambles, content split by ads\n      // that we removed, etc.\n      var articleContent = doc.createElement(\"DIV\");\n      if (isPaging)\n        articleContent.id = \"readability-content\";\n\n      var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);\n      // Keep potential top candidate's parent node to try to get text direction of it later.\n      parentOfTopCandidate = topCandidate.parentNode;\n      var siblings = parentOfTopCandidate.children;\n\n      for (var s = 0, sl = siblings.length; s < sl; s++) {\n        var sibling = siblings[s];\n        var append = false;\n\n        this.log(\"Looking at sibling node:\", sibling, sibling.readability ? (\"with score \" + sibling.readability.contentScore) : \"\");\n        this.log(\"Sibling has score\", sibling.readability ? sibling.readability.contentScore : \"Unknown\");\n\n        if (sibling === topCandidate) {\n          append = true;\n        } else {\n          var contentBonus = 0;\n\n          // Give a bonus if sibling nodes and top candidates have the example same classname\n          if (sibling.className === topCandidate.className && topCandidate.className !== \"\")\n            contentBonus += topCandidate.readability.contentScore * 0.2;\n\n          if (sibling.readability &&\n              ((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {\n            append = true;\n          } else if (sibling.nodeName === \"P\") {\n            var linkDensity = this._getLinkDensity(sibling);\n            var nodeContent = this._getInnerText(sibling);\n            var nodeLength = nodeContent.length;\n\n            if (nodeLength > 80 && linkDensity < 0.25) {\n              append = true;\n            } else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&\n                       nodeContent.search(/\\.( |$)/) !== -1) {\n              append = true;\n            }\n          }\n        }\n\n        if (append) {\n          this.log(\"Appending node:\", sibling);\n\n          if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {\n            // We have a node that isn't a common block level element, like a form or td tag.\n            // Turn it into a div so it doesn't get filtered out later by accident.\n            this.log(\"Altering sibling:\", sibling, \"to div.\");\n\n            sibling = this._setNodeTag(sibling, \"DIV\");\n          }\n\n          articleContent.appendChild(sibling);\n          // siblings is a reference to the children array, and\n          // sibling is removed from the array when we call appendChild().\n          // As a result, we must revisit this index since the nodes\n          // have been shifted.\n          s -= 1;\n          sl -= 1;\n        }\n      }\n\n      if (this._debug)\n        this.log(\"Article content pre-prep: \" + articleContent.innerHTML);\n      // So we have all of the content that we need. Now we clean it up for presentation.\n      this._prepArticle(articleContent);\n      if (this._debug)\n        this.log(\"Article content post-prep: \" + articleContent.innerHTML);\n\n      if (neededToCreateTopCandidate) {\n        // We already created a fake div thing, and there wouldn't have been any siblings left\n        // for the previous loop, so there's no point trying to create a new div, and then\n        // move all the children over. Just assign IDs and class names here. No need to append\n        // because that already happened anyway.\n        topCandidate.id = \"readability-page-1\";\n        topCandidate.className = \"page\";\n      } else {\n        var div = doc.createElement(\"DIV\");\n        div.id = \"readability-page-1\";\n        div.className = \"page\";\n        var children = articleContent.childNodes;\n        while (children.length) {\n          div.appendChild(children[0]);\n        }\n        articleContent.appendChild(div);\n      }\n\n      if (this._debug)\n        this.log(\"Article content after paging: \" + articleContent.innerHTML);\n\n      var parseSuccessful = true;\n\n      // Now that we've gone through the full algorithm, check to see if\n      // we got any meaningful content. If we didn't, we may need to re-run\n      // grabArticle with different flags set. This gives us a higher likelihood of\n      // finding the content, and the sieve approach gives us a higher likelihood of\n      // finding the -right- content.\n      var textLength = this._getInnerText(articleContent, true).length;\n      if (textLength < this._charThreshold) {\n        parseSuccessful = false;\n        page.innerHTML = pageCacheHtml;\n\n        if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {\n          this._removeFlag(this.FLAG_STRIP_UNLIKELYS);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {\n          this._removeFlag(this.FLAG_WEIGHT_CLASSES);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {\n          this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n        } else {\n          this._attempts.push({articleContent: articleContent, textLength: textLength});\n          // No luck after removing flags, just return the longest text we found during the different loops\n          this._attempts.sort(function (a, b) {\n            return b.textLength - a.textLength;\n          });\n\n          // But first check if we actually have something\n          if (!this._attempts[0].textLength) {\n            return null;\n          }\n\n          articleContent = this._attempts[0].articleContent;\n          parseSuccessful = true;\n        }\n      }\n\n      if (parseSuccessful) {\n        // Find out text direction from ancestors of final top candidate.\n        var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));\n        this._someNode(ancestors, function(ancestor) {\n          if (!ancestor.tagName)\n            return false;\n          var articleDir = ancestor.getAttribute(\"dir\");\n          if (articleDir) {\n            this._articleDir = articleDir;\n            return true;\n          }\n          return false;\n        });\n        return articleContent;\n      }\n    }\n  },\n\n  /**\n   * Check whether the input string could be a byline.\n   * This verifies that the input is a string, and that the length\n   * is less than 100 chars.\n   *\n   * @param possibleByline {string} - a string to check whether its a byline.\n   * @return Boolean - whether the input string is a byline.\n   */\n  _isValidByline: function(byline) {\n    if (typeof byline == \"string\" || byline instanceof String) {\n      byline = byline.trim();\n      return (byline.length > 0) && (byline.length < 100);\n    }\n    return false;\n  },\n\n  /**\n   * Converts some of the common HTML entities in string to their corresponding characters.\n   *\n   * @param str {string} - a string to unescape.\n   * @return string without HTML entity.\n   */\n  _unescapeHtmlEntities: function(str) {\n    if (!str) {\n      return str;\n    }\n\n    var htmlEscapeMap = this.HTML_ESCAPE_MAP;\n    return str.replace(/&(quot|amp|apos|lt|gt);/g, function(_, tag) {\n      return htmlEscapeMap[tag];\n    }).replace(/&#(?:x([0-9a-z]{1,4})|([0-9]{1,4}));/gi, function(_, hex, numStr) {\n      var num = parseInt(hex || numStr, hex ? 16 : 10);\n      return String.fromCharCode(num);\n    });\n  },\n\n  /**\n   * Attempts to get excerpt and byline metadata for the article.\n   *\n   * @return Object with optional \"excerpt\" and \"byline\" properties\n   */\n  _getArticleMetadata: function() {\n    var metadata = {};\n    var values = {};\n    var metaElements = this._doc.getElementsByTagName(\"meta\");\n\n    // property is a space-separated list of values\n    var propertyPattern = /\\s*(dc|dcterm|og|twitter)\\s*:\\s*(author|creator|description|title|site_name)\\s*/gi;\n\n    // name is a single value\n    var namePattern = /^\\s*(?:(dc|dcterm|og|twitter|weibo:(article|webpage))\\s*[\\.:]\\s*)?(author|creator|description|title|site_name)\\s*$/i;\n\n    // Find description tags.\n    this._forEachNode(metaElements, function(element) {\n      var elementName = element.getAttribute(\"name\");\n      var elementProperty = element.getAttribute(\"property\");\n      var content = element.getAttribute(\"content\");\n      if (!content) {\n        return;\n      }\n      var matches = null;\n      var name = null;\n\n      if (elementProperty) {\n        matches = elementProperty.match(propertyPattern);\n        if (matches) {\n          for (var i = matches.length - 1; i >= 0; i--) {\n            // Convert to lowercase, and remove any whitespace\n            // so we can match below.\n            name = matches[i].toLowerCase().replace(/\\s/g, \"\");\n            // multiple authors\n            values[name] = content.trim();\n          }\n        }\n      }\n      if (!matches && elementName && namePattern.test(elementName)) {\n        name = elementName;\n        if (content) {\n          // Convert to lowercase, remove any whitespace, and convert dots\n          // to colons so we can match below.\n          name = name.toLowerCase().replace(/\\s/g, \"\").replace(/\\./g, \":\");\n          values[name] = content.trim();\n        }\n      }\n    });\n\n    // get title\n    metadata.title = values[\"dc:title\"] ||\n                     values[\"dcterm:title\"] ||\n                     values[\"og:title\"] ||\n                     values[\"weibo:article:title\"] ||\n                     values[\"weibo:webpage:title\"] ||\n                     values[\"title\"] ||\n                     values[\"twitter:title\"];\n\n    if (!metadata.title) {\n      metadata.title = this._getArticleTitle();\n    }\n\n    // get author\n    metadata.byline = values[\"dc:creator\"] ||\n                      values[\"dcterm:creator\"] ||\n                      values[\"author\"];\n\n    // get description\n    metadata.excerpt = values[\"dc:description\"] ||\n                       values[\"dcterm:description\"] ||\n                       values[\"og:description\"] ||\n                       values[\"weibo:article:description\"] ||\n                       values[\"weibo:webpage:description\"] ||\n                       values[\"description\"] ||\n                       values[\"twitter:description\"];\n\n    // get site name\n    metadata.siteName = values[\"og:site_name\"];\n\n    // in many sites the meta value is escaped with HTML entities,\n    // so here we need to unescape it\n    metadata.title = this._unescapeHtmlEntities(metadata.title);\n    metadata.byline = this._unescapeHtmlEntities(metadata.byline);\n    metadata.excerpt = this._unescapeHtmlEntities(metadata.excerpt);\n    metadata.siteName = this._unescapeHtmlEntities(metadata.siteName);\n\n    return metadata;\n  },\n\n  /**\n   * Check if node is image, or if node contains exactly only one image\n   * whether as a direct child or as its descendants.\n   *\n   * @param Element\n  **/\n  _isSingleImage: function(node) {\n    if (node.tagName === \"IMG\") {\n      return true;\n    }\n\n    if (node.children.length !== 1 || node.textContent.trim() !== \"\") {\n      return false;\n    }\n\n    return this._isSingleImage(node.children[0]);\n  },\n\n  /**\n   * Find all <noscript> that are located after <img> nodes, and which contain only one\n   * <img> element. Replace the first image with the image from inside the <noscript> tag,\n   * and remove the <noscript> tag. This improves the quality of the images we use on\n   * some sites (e.g. Medium).\n   *\n   * @param Element\n  **/\n  _unwrapNoscriptImages: function(doc) {\n    // Find img without source or attributes that might contains image, and remove it.\n    // This is done to prevent a placeholder img is replaced by img from noscript in next step.\n    var imgs = Array.from(doc.getElementsByTagName(\"img\"));\n    this._forEachNode(imgs, function(img) {\n      for (var i = 0; i < img.attributes.length; i++) {\n        var attr = img.attributes[i];\n        switch (attr.name) {\n          case \"src\":\n          case \"srcset\":\n          case \"data-src\":\n          case \"data-srcset\":\n            return;\n        }\n\n        if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n          return;\n        }\n      }\n\n      img.parentNode.removeChild(img);\n    });\n\n    // Next find noscript and try to extract its image\n    var noscripts = Array.from(doc.getElementsByTagName(\"noscript\"));\n    this._forEachNode(noscripts, function(noscript) {\n      // Parse content of noscript and make sure it only contains image\n      var tmp = doc.createElement(\"div\");\n      tmp.innerHTML = noscript.innerHTML;\n      if (!this._isSingleImage(tmp)) {\n        return;\n      }\n\n      // If noscript has previous sibling and it only contains image,\n      // replace it with noscript content. However we also keep old\n      // attributes that might contains image.\n      var prevElement = noscript.previousElementSibling;\n      if (prevElement && this._isSingleImage(prevElement)) {\n        var prevImg = prevElement;\n        if (prevImg.tagName !== \"IMG\") {\n          prevImg = prevElement.getElementsByTagName(\"img\")[0];\n        }\n\n        var newImg = tmp.getElementsByTagName(\"img\")[0];\n        for (var i = 0; i < prevImg.attributes.length; i++) {\n          var attr = prevImg.attributes[i];\n          if (attr.value === \"\") {\n            continue;\n          }\n\n          if (attr.name === \"src\" || attr.name === \"srcset\" || /\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            if (newImg.getAttribute(attr.name) === attr.value) {\n              continue;\n            }\n\n            var attrName = attr.name;\n            if (newImg.hasAttribute(attrName)) {\n              attrName = \"data-old-\" + attrName;\n            }\n\n            newImg.setAttribute(attrName, attr.value);\n          }\n        }\n\n        noscript.parentNode.replaceChild(tmp.firstElementChild, prevElement);\n      }\n    });\n  },\n\n  /**\n   * Removes script tags from the document.\n   *\n   * @param Element\n  **/\n  _removeScripts: function(doc) {\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"script\"]), function(scriptNode) {\n      scriptNode.nodeValue = \"\";\n      scriptNode.removeAttribute(\"src\");\n      return true;\n    });\n    this._removeNodes(this._getAllNodesWithTag(doc, [\"noscript\"]));\n  },\n\n  /**\n   * Check if this node has only whitespace and a single element with given tag\n   * Returns false if the DIV node contains non-empty text nodes\n   * or if it contains no element with given tag or more than 1 element.\n   *\n   * @param Element\n   * @param string tag of child element\n  **/\n  _hasSingleTagInsideElement: function(element, tag) {\n    // There should be exactly 1 element child with given tag\n    if (element.children.length != 1 || element.children[0].tagName !== tag) {\n      return false;\n    }\n\n    // And there should be no text nodes with real content\n    return !this._someNode(element.childNodes, function(node) {\n      return node.nodeType === this.TEXT_NODE &&\n             this.REGEXPS.hasContent.test(node.textContent);\n    });\n  },\n\n  _isElementWithoutContent: function(node) {\n    return node.nodeType === this.ELEMENT_NODE &&\n      node.textContent.trim().length == 0 &&\n      (node.children.length == 0 ||\n       node.children.length == node.getElementsByTagName(\"br\").length + node.getElementsByTagName(\"hr\").length);\n  },\n\n  /**\n   * Determine whether element has any children block level elements.\n   *\n   * @param Element\n   */\n  _hasChildBlockElement: function (element) {\n    return this._someNode(element.childNodes, function(node) {\n      return this.DIV_TO_P_ELEMS.indexOf(node.tagName) !== -1 ||\n             this._hasChildBlockElement(node);\n    });\n  },\n\n  /***\n   * Determine if a node qualifies as phrasing content.\n   * https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories#Phrasing_content\n  **/\n  _isPhrasingContent: function(node) {\n    return node.nodeType === this.TEXT_NODE || this.PHRASING_ELEMS.indexOf(node.tagName) !== -1 ||\n      ((node.tagName === \"A\" || node.tagName === \"DEL\" || node.tagName === \"INS\") &&\n        this._everyNode(node.childNodes, this._isPhrasingContent));\n  },\n\n  _isWhitespace: function(node) {\n    return (node.nodeType === this.TEXT_NODE && node.textContent.trim().length === 0) ||\n           (node.nodeType === this.ELEMENT_NODE && node.tagName === \"BR\");\n  },\n\n  /**\n   * Get the inner text of a node - cross browser compatibly.\n   * This also strips out any excess whitespace to be found.\n   *\n   * @param Element\n   * @param Boolean normalizeSpaces (default: true)\n   * @return string\n  **/\n  _getInnerText: function(e, normalizeSpaces) {\n    normalizeSpaces = (typeof normalizeSpaces === \"undefined\") ? true : normalizeSpaces;\n    var textContent = e.textContent.trim();\n\n    if (normalizeSpaces) {\n      return textContent.replace(this.REGEXPS.normalize, \" \");\n    }\n    return textContent;\n  },\n\n  /**\n   * Get the number of times a string s appears in the node e.\n   *\n   * @param Element\n   * @param string - what to split on. Default is \",\"\n   * @return number (integer)\n  **/\n  _getCharCount: function(e, s) {\n    s = s || \",\";\n    return this._getInnerText(e).split(s).length - 1;\n  },\n\n  /**\n   * Remove the style attribute on every e and under.\n   * TODO: Test if getElementsByTagName(*) is faster.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanStyles: function(e) {\n    if (!e || e.tagName.toLowerCase() === \"svg\")\n      return;\n\n    // Remove `style` and deprecated presentational attributes\n    for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {\n      e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);\n    }\n\n    if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {\n      e.removeAttribute(\"width\");\n      e.removeAttribute(\"height\");\n    }\n\n    var cur = e.firstElementChild;\n    while (cur !== null) {\n      this._cleanStyles(cur);\n      cur = cur.nextElementSibling;\n    }\n  },\n\n  /**\n   * Get the density of links as a percentage of the content\n   * This is the amount of text that is inside a link divided by the total text in the node.\n   *\n   * @param Element\n   * @return number (float)\n  **/\n  _getLinkDensity: function(element) {\n    var textLength = this._getInnerText(element).length;\n    if (textLength === 0)\n      return 0;\n\n    var linkLength = 0;\n\n    // XXX implement _reduceNodeList?\n    this._forEachNode(element.getElementsByTagName(\"a\"), function(linkNode) {\n      linkLength += this._getInnerText(linkNode).length;\n    });\n\n    return linkLength / textLength;\n  },\n\n  /**\n   * Get an elements class/id weight. Uses regular expressions to tell if this\n   * element looks good or bad.\n   *\n   * @param Element\n   * @return number (Integer)\n  **/\n  _getClassWeight: function(e) {\n    if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))\n      return 0;\n\n    var weight = 0;\n\n    // Look for a special classname\n    if (typeof(e.className) === \"string\" && e.className !== \"\") {\n      if (this.REGEXPS.negative.test(e.className))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.className))\n        weight += 25;\n    }\n\n    // Look for a special ID\n    if (typeof(e.id) === \"string\" && e.id !== \"\") {\n      if (this.REGEXPS.negative.test(e.id))\n        weight -= 25;\n\n      if (this.REGEXPS.positive.test(e.id))\n        weight += 25;\n    }\n\n    return weight;\n  },\n\n  /**\n   * Clean a node of all elements of type \"tag\".\n   * (Unless it's a youtube/vimeo video. People love movies.)\n   *\n   * @param Element\n   * @param string tag to clean\n   * @return void\n   **/\n  _clean: function(e, tag) {\n    var isEmbed = [\"object\", \"embed\", \"iframe\"].indexOf(tag) !== -1;\n\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(element) {\n      // Allow youtube and vimeo videos through as people usually want to see those.\n      if (isEmbed) {\n        // First, check the elements attributes to see if any of them contain youtube or vimeo\n        for (var i = 0; i < element.attributes.length; i++) {\n          if (this.REGEXPS.videos.test(element.attributes[i].value)) {\n            return false;\n          }\n        }\n\n        // For embed with <object> tag, check inner HTML as well.\n        if (element.tagName === \"object\" && this.REGEXPS.videos.test(element.innerHTML)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n  },\n\n  /**\n   * Check if a given node has one of its ancestor tag name matching the\n   * provided one.\n   * @param  HTMLElement node\n   * @param  String      tagName\n   * @param  Number      maxDepth\n   * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'\n   * @return Boolean\n   */\n  _hasAncestorTag: function(node, tagName, maxDepth, filterFn) {\n    maxDepth = maxDepth || 3;\n    tagName = tagName.toUpperCase();\n    var depth = 0;\n    while (node.parentNode) {\n      if (maxDepth > 0 && depth > maxDepth)\n        return false;\n      if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))\n        return true;\n      node = node.parentNode;\n      depth++;\n    }\n    return false;\n  },\n\n  /**\n   * Return an object indicating how many rows and columns this table has.\n   */\n  _getRowAndColumnCount: function(table) {\n    var rows = 0;\n    var columns = 0;\n    var trs = table.getElementsByTagName(\"tr\");\n    for (var i = 0; i < trs.length; i++) {\n      var rowspan = trs[i].getAttribute(\"rowspan\") || 0;\n      if (rowspan) {\n        rowspan = parseInt(rowspan, 10);\n      }\n      rows += (rowspan || 1);\n\n      // Now look for column-related info\n      var columnsInThisRow = 0;\n      var cells = trs[i].getElementsByTagName(\"td\");\n      for (var j = 0; j < cells.length; j++) {\n        var colspan = cells[j].getAttribute(\"colspan\") || 0;\n        if (colspan) {\n          colspan = parseInt(colspan, 10);\n        }\n        columnsInThisRow += (colspan || 1);\n      }\n      columns = Math.max(columns, columnsInThisRow);\n    }\n    return {rows: rows, columns: columns};\n  },\n\n  /**\n   * Look for 'data' (as opposed to 'layout') tables, for which we use\n   * similar checks as\n   * https://dxr.mozilla.org/mozilla-central/rev/71224049c0b52ab190564d3ea0eab089a159a4cf/accessible/html/HTMLTableAccessible.cpp#920\n   */\n  _markDataTables: function(root) {\n    var tables = root.getElementsByTagName(\"table\");\n    for (var i = 0; i < tables.length; i++) {\n      var table = tables[i];\n      var role = table.getAttribute(\"role\");\n      if (role == \"presentation\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var datatable = table.getAttribute(\"datatable\");\n      if (datatable == \"0\") {\n        table._readabilityDataTable = false;\n        continue;\n      }\n      var summary = table.getAttribute(\"summary\");\n      if (summary) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      var caption = table.getElementsByTagName(\"caption\")[0];\n      if (caption && caption.childNodes.length > 0) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // If the table has a descendant with any of these tags, consider a data table:\n      var dataTableDescendants = [\"col\", \"colgroup\", \"tfoot\", \"thead\", \"th\"];\n      var descendantExists = function(tag) {\n        return !!table.getElementsByTagName(tag)[0];\n      };\n      if (dataTableDescendants.some(descendantExists)) {\n        this.log(\"Data table because found data-y descendant\");\n        table._readabilityDataTable = true;\n        continue;\n      }\n\n      // Nested tables indicate a layout table:\n      if (table.getElementsByTagName(\"table\")[0]) {\n        table._readabilityDataTable = false;\n        continue;\n      }\n\n      var sizeInfo = this._getRowAndColumnCount(table);\n      if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {\n        table._readabilityDataTable = true;\n        continue;\n      }\n      // Now just go by size entirely:\n      table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;\n    }\n  },\n\n  /* convert images and figures that have properties like data-src into images that can be loaded without JS */\n  _fixLazyImages: function (root) {\n    this._forEachNode(this._getAllNodesWithTag(root, [\"img\", \"picture\", \"figure\"]), function (elem) {\n      // In some sites (e.g. Kotaku), they put 1px square image as base64 data uri in the src attribute.\n      // So, here we check if the data uri is too short, just might as well remove it.\n      if (elem.src && this.REGEXPS.b64DataUrl.test(elem.src)) {\n        // Make sure it's not SVG, because SVG can have a meaningful image in under 133 bytes.\n        var parts = this.REGEXPS.b64DataUrl.exec(elem.src);\n        if (parts[1] === \"image/svg+xml\") {\n          return;\n        }\n\n        // Make sure this element has other attributes which contains image.\n        // If it doesn't, then this src is important and shouldn't be removed.\n        var srcCouldBeRemoved = false;\n        for (var i = 0; i < elem.attributes.length; i++) {\n          var attr = elem.attributes[i];\n          if (attr.name === \"src\") {\n            continue;\n          }\n\n          if (/\\.(jpg|jpeg|png|webp)/i.test(attr.value)) {\n            srcCouldBeRemoved = true;\n            break;\n          }\n        }\n\n        // Here we assume if image is less than 100 bytes (or 133B after encoded to base64)\n        // it will be too small, therefore it might be placeholder image.\n        if (srcCouldBeRemoved) {\n          var b64starts = elem.src.search(/base64\\s*/i) + 7;\n          var b64length = elem.src.length - b64starts;\n          if (b64length < 133) {\n            elem.removeAttribute(\"src\");\n          }\n        }\n      }\n\n      // also check for \"null\" to work around https://github.com/jsdom/jsdom/issues/2580\n      if ((elem.src || (elem.srcset && elem.srcset != \"null\")) && elem.className.toLowerCase().indexOf(\"lazy\") === -1) {\n        return;\n      }\n\n      for (var j = 0; j < elem.attributes.length; j++) {\n        attr = elem.attributes[j];\n        if (attr.name === \"src\" || attr.name === \"srcset\") {\n          continue;\n        }\n        var copyTo = null;\n        if (/\\.(jpg|jpeg|png|webp)\\s+\\d/.test(attr.value)) {\n          copyTo = \"srcset\";\n        } else if (/^\\s*\\S+\\.(jpg|jpeg|png|webp)\\S*\\s*$/.test(attr.value)) {\n          copyTo = \"src\";\n        }\n        if (copyTo) {\n          //if this is an img or picture, set the attribute directly\n          if (elem.tagName === \"IMG\" || elem.tagName === \"PICTURE\") {\n            elem.setAttribute(copyTo, attr.value);\n          } else if (elem.tagName === \"FIGURE\" && !this._getAllNodesWithTag(elem, [\"img\", \"picture\"]).length) {\n            //if the item is a <figure> that does not contain an image or picture, create one and place it inside the figure\n            //see the nytimes-3 testcase for an example\n            var img = this._doc.createElement(\"img\");\n            img.setAttribute(copyTo, attr.value);\n            elem.appendChild(img);\n          }\n        }\n      }\n    });\n  },\n\n  /**\n   * Clean an element of all tags of type \"tag\" if they look fishy.\n   * \"Fishy\" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.\n   *\n   * @return void\n   **/\n  _cleanConditionally: function(e, tag) {\n    if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))\n      return;\n\n    var isList = tag === \"ul\" || tag === \"ol\";\n\n    // Gather counts for other typical elements embedded within.\n    // Traverse backwards so we can remove nodes at the same time\n    // without effecting the traversal.\n    //\n    // TODO: Consider taking into account original contentScore here.\n    this._removeNodes(this._getAllNodesWithTag(e, [tag]), function(node) {\n      // First check if this node IS data table, in which case don't remove it.\n      var isDataTable = function(t) {\n        return t._readabilityDataTable;\n      };\n\n      if (tag === \"table\" && isDataTable(node)) {\n        return false;\n      }\n\n      // Next check if we're inside a data table, in which case don't remove it as well.\n      if (this._hasAncestorTag(node, \"table\", -1, isDataTable)) {\n        return false;\n      }\n\n      var weight = this._getClassWeight(node);\n      var contentScore = 0;\n\n      this.log(\"Cleaning Conditionally\", node);\n\n      if (weight + contentScore < 0) {\n        return true;\n      }\n\n      if (this._getCharCount(node, \",\") < 10) {\n        // If there are not very many commas, and the number of\n        // non-paragraph elements is more than paragraphs or other\n        // ominous signs, remove the element.\n        var p = node.getElementsByTagName(\"p\").length;\n        var img = node.getElementsByTagName(\"img\").length;\n        var li = node.getElementsByTagName(\"li\").length - 100;\n        var input = node.getElementsByTagName(\"input\").length;\n\n        var embedCount = 0;\n        var embeds = this._getAllNodesWithTag(node, [\"object\", \"embed\", \"iframe\"]);\n\n        for (var i = 0; i < embeds.length; i++) {\n          // If this embed has attribute that matches video regex, don't delete it.\n          for (var j = 0; j < embeds[i].attributes.length; j++) {\n            if (this.REGEXPS.videos.test(embeds[i].attributes[j].value)) {\n              return false;\n            }\n          }\n\n          // For embed with <object> tag, check inner HTML as well.\n          if (embeds[i].tagName === \"object\" && this.REGEXPS.videos.test(embeds[i].innerHTML)) {\n            return false;\n          }\n\n          embedCount++;\n        }\n\n        var linkDensity = this._getLinkDensity(node);\n        var contentLength = this._getInnerText(node).length;\n\n        var haveToRemove =\n          (img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && li > p) ||\n          (input > Math.floor(p/3)) ||\n          (!isList && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, \"figure\")) ||\n          (!isList && weight < 25 && linkDensity > 0.2) ||\n          (weight >= 25 && linkDensity > 0.5) ||\n          ((embedCount === 1 && contentLength < 75) || embedCount > 1);\n        return haveToRemove;\n      }\n      return false;\n    });\n  },\n\n  /**\n   * Clean out elements that match the specified conditions\n   *\n   * @param Element\n   * @param Function determines whether a node should be removed\n   * @return void\n   **/\n  _cleanMatchedNodes: function(e, filter) {\n    var endOfSearchMarkerNode = this._getNextNode(e, true);\n    var next = this._getNextNode(e);\n    while (next && next != endOfSearchMarkerNode) {\n      if (filter.call(this, next, next.className + \" \" + next.id)) {\n        next = this._removeAndGetNext(next);\n      } else {\n        next = this._getNextNode(next);\n      }\n    }\n  },\n\n  /**\n   * Clean out spurious headers from an Element. Checks things like classnames and link density.\n   *\n   * @param Element\n   * @return void\n  **/\n  _cleanHeaders: function(e) {\n    this._removeNodes(this._getAllNodesWithTag(e, [\"h1\", \"h2\"]), function (header) {\n      return this._getClassWeight(header) < 0;\n    });\n  },\n\n  _flagIsActive: function(flag) {\n    return (this._flags & flag) > 0;\n  },\n\n  _removeFlag: function(flag) {\n    this._flags = this._flags & ~flag;\n  },\n\n  _isProbablyVisible: function(node) {\n    // Have to null-check node.style and node.className.indexOf to deal with SVG and MathML nodes.\n    return (!node.style || node.style.display != \"none\")\n      && !node.hasAttribute(\"hidden\")\n      //check for \"fallback-image\" so that wikimedia math images are displayed\n      && (!node.hasAttribute(\"aria-hidden\") || node.getAttribute(\"aria-hidden\") != \"true\" || (node.className && node.className.indexOf && node.className.indexOf(\"fallback-image\") !== -1));\n  },\n\n  /**\n   * Runs readability.\n   *\n   * Workflow:\n   *  1. Prep the document by removing script tags, css, etc.\n   *  2. Build readability's DOM tree.\n   *  3. Grab the article content from the current dom tree.\n   *  4. Replace the current DOM tree with the new one.\n   *  5. Read peacefully.\n   *\n   * @return void\n   **/\n  parse: function () {\n    // Avoid parsing too large documents, as per configuration option\n    if (this._maxElemsToParse > 0) {\n      var numTags = this._doc.getElementsByTagName(\"*\").length;\n      if (numTags > this._maxElemsToParse) {\n        throw new Error(\"Aborting parsing document; \" + numTags + \" elements found\");\n      }\n    }\n\n    // Unwrap image from noscript\n    this._unwrapNoscriptImages(this._doc);\n\n    // Remove script tags from the document.\n    this._removeScripts(this._doc);\n\n    this._prepDocument();\n\n    var metadata = this._getArticleMetadata();\n    this._articleTitle = metadata.title;\n\n    var articleContent = this._grabArticle();\n    if (!articleContent)\n      return null;\n\n    this.log(\"Grabbed: \" + articleContent.innerHTML);\n\n    this._postProcessContent(articleContent);\n\n    // If we haven't found an excerpt in the article's metadata, use the article's\n    // first paragraph as the excerpt. This is used for displaying a preview of\n    // the article's content.\n    if (!metadata.excerpt) {\n      var paragraphs = articleContent.getElementsByTagName(\"p\");\n      if (paragraphs.length > 0) {\n        metadata.excerpt = paragraphs[0].textContent.trim();\n      }\n    }\n\n    var textContent = articleContent.textContent;\n    return {\n      title: this._articleTitle,\n      byline: metadata.byline || this._articleByline,\n      dir: this._articleDir,\n      content: articleContent.innerHTML,\n      textContent: textContent,\n      length: textContent.length,\n      excerpt: metadata.excerpt,\n      siteName: metadata.siteName || this._articleSiteName\n    };\n  }\n};\n\nif (typeof module === \"object\") {\n  module.exports = Readability;\n}\n","/**\n * @copyright Copyright (c) 2016-present, TagSpaces UG (haftungsbeschraenkt).\n * @license AGPL-3.0\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License, version 3,\n * as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License, version 3,\n * along with this program.  If not, see <http://www.gnu.org/licenses/>\n *\n */\n\"use strict\";\nimport Readability from 'readability';\n\nconst isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;\n\nfunction getCleanedHtml() {\n  try {\n    const loc = document.location;\n    const uri = {\n      spec: loc.href,\n      host: loc.host,\n      prePath: loc.protocol + \"//\" + loc.host,\n      scheme: loc.protocol.substr(0, loc.protocol.indexOf(\":\")),\n      pathBase: loc.protocol + \"//\" + loc.host + loc.pathname.substr(0, loc.pathname.lastIndexOf(\"/\") + 1)\n    };\n    const documentClone = document.cloneNode(true);\n    const article = new Readability(uri, documentClone).parse();\n    let extractedContent = '<h1>' + article.title + '</h1>' + article.content\n    return extractedContent;\n  } catch (error) {\n    console.warn('Error parsing document, sending original content');\n    return undefined;\n  }\n}\n\nfunction getOriginalHtml() {\n  let body = document.body.innerHTML;\n  let head = document.head.innerHTML;\n  return '<html><head>' + head + '</head><body>' + body + '</body></htlm>';\n}\n\nconst contentMsg = {\n  action: \"htmlcontent\",\n  cleanedHTML: getCleanedHtml(),\n  originalHTML: getOriginalHtml()\n};\nisFirefox ? browser.runtime.sendMessage(contentMsg) : chrome.runtime.sendMessage(contentMsg);\n"],"sourceRoot":""}